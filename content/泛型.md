[Generic Data Types](https://doc.rust-lang.org/book/ch10-01-syntax.html#generic-data-types)，了解泛型的使用。

Rust 的泛型与 TypeScript 的泛型类似，但更加强大，例如在实现 struct 方法的时候，如果指定类型的话，则该方法仅在这种类型下才能使用，如：

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        let tmp = (self.x.powi(2) + self.y.powi(2)).sqrt();
        println!("distance_from_origin: {}", tmp);
        tmp
    }
}

fn main() {
    let a = Point { x: 1.0_f64, y: 2.0_f64 };
    a.x();
    a.distance_from_origin(); // 这里会报错，因为只有 Point<f32> 才有 distance_from_origin 方法

    let b = Point {
        x: 1.0_f32,
        y: 2.0_f32,
    };
    b.x();
    b.distance_from_origin(); // 这里正常
}
```

在使用泛型的时候，无需担心会影响运行时的性能，monomorphization（单态化）会在编译时根据具体的类型生成特定的代码实例。这种方式可以消除泛型引入的性能损失，并且在编译时进行类型检查。